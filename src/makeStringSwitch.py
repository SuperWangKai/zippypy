# Copyright 2015 by Intigua, Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function
import sys

""" This module has stringSwitch - takes a dictionary and creates c++ code which maps string to value """
    

class RecStrSw:
    def __init__(self, strValue):
        self.strValue = strValue
        
    def _recStrSw(self, file, strsTL, level, charOffset, maxLen):
        """ maxLen - length of the strings in this case """
        indent = " "*level
        if len(strsTL) == 1:
            k = strsTL[0][0]
            v = strsTL[0][1]
            
            print('%sk = "%s";' % (indent, k), file=file)
            print('%s%s' % (indent, self.strValue(v) % {"indent":indent}), file=file)

            return
        
        assert charOffset < maxLen # sanity
        byletter = {}
        for k,v in strsTL:
            d = byletter.get(k[charOffset], None)
            if d is None:
                d = byletter[k[charOffset]] = []
            d.append((k,v))
        if len(byletter) == 1: #only one option, skip doing if
            self._recStrSw(file, strsTL, level, charOffset + 1, maxLen)
            return
        items = byletter.items()
        items.sort(cmp=(lambda a,b: len(b[1])-len(a[1]))) # sort by the size of the set    
        addElse = ""
        for l,strset in items:
            comment = " // %d options" % len(strset) if len(strset) > 1 else ""
            print("%s%sif (s[%d] == '%s') {%s" % (indent, addElse, charOffset, l, comment), file=file)
            self._recStrSw(file, strset, level + 4, charOffset + 1, maxLen)
            print("%s}" % indent, file=file)
            addElse = "else "

    def _strBySize(self, file, strsTL, level):
        """ strsTL - list of tuples (name, value) """
        indent = " "*level
        bysize = {}
        for k,v in strsTL:
            d = bysize.get(len(k), None)
            if d is None:
                d = bysize[len(k)] = []
            d.append((k,v))
        items = bysize.items()
        items.sort(cmp=(lambda a,b: len(b[1])-len(a[1]))) # sort by the size of the set  
        print("%sswitch(sz)\n%s{" % (indent, indent), file=file)
        for sz,strset in items:
            comment = " // %d options" % len(strset) if len(strset) > 1 else ""
            print("%scase %d: {%s" % (indent, sz, comment), file=file)
            self._recStrSw(file, strset, level + 4, 0, sz)
            print("%s    break;" % indent, file=file)
            print("%s} // case %d" % (indent, sz), file=file)
        print("%s} // switch(sz)" %  indent, file=file)

class CharBufPrinter:
    def __init__(self):
        self.buffersSize = 0
    def printHeader(self):
        return ""
    def printInit(self):
        return "    const char *v = NULL;\n    int vsz = -1;"
    def printValue(self, v):
        self.buffersSize += v["lengthv"]
        return 'vsz = %d; v = "%s";' % (v["lengthv"], v["stringv"])
    def printReturn(self):
        return "    *retSz = vsz;\n    return v;"
    def printReturnNone(self):
        return "    return NULL;"
    def printSig(self):
        return ("const char*", ", int* retSz")
    def printFooter(self):
        return "// total buffers size=%d" % self.buffersSize
    
def stringSwitch(file, strsDict, funcname):
    # gets a dict mapping string -> {"lengthv":123, "stringv":"XXXXXX"}
    genericSwitch(file, strsDict, funcname, CharBufPrinter())

class CharPVectorPrinter:
    def printHeader(self):
        return "#include<vector>\n\ntypedef std::vector<std::pair<const char*, const char*>> VPCC;"
    def printInit(self):
        return "    VPCC v;"
    def printValue(self, v):
        return '\n%(indent)s'.join([ ('v.push_back(std::make_pair("%s", "%s"));' % (s[0], s[1]) ) for s in v])
    def printReturn(self):
        return "    return v;"
    def printReturnNone(self):
        return "    return VPCC();"
    def printSig(self):
        return ("VPCC", "")
    def printFooter(self):
        return ""


def charPVectorSwitch(file, d, funcname):
    genericSwitch(file, d, funcname, CharPVectorPrinter())

# this function calls functions in prn to print the various type-dependent items needed for the switch
def genericSwitch(file, strsDict, funcname, prn):         
    print("// Do not directly edit this file. this file is auto generated by a custom build step\n", file=file)
    print("#include<string>\n", file=file)
    print(prn.printHeader(), file=file)
    retType, addType = prn.printSig()
    print(retType + " "+ funcname + "(const std::string& s" + addType + ")\n{", file=file)
    print("    const char *k = NULL;", file=file)
    print(prn.printInit(), file=file)
    print("    int sz = (int)s.size();", file=file)
    RecStrSw(prn.printValue)._strBySize(file, strsDict.items(), 4);
    print("\n    if (k == NULL || s != k)\n    %s\n" % prn.printReturnNone(), file=file)
    print(prn.printReturn(), file=file)
    print("}", file=file)
    print(prn.printFooter(), file=file)



def stringEnumSwitch(inFileName, outName, funcname, enumName, prefix):
    names = {}
    for s in open(inFileName):
        s = s.strip()
        names[s] = prefix + s.upper()
    file = open(outName, 'w')
    headerFile = file

    print("// Do not directly edit this file. this file is auto generated by a custom build step\n", file=headerFile)
    print("enum " + enumName + "\n{", file=headerFile)
    index = 1
    for e in sorted(list(set(names.values()))): # sorted list of the unique values from names
        print("    " + e + (" = 1" if index == 1 else "") + ",", file=headerFile);
        index += 1
    print("};\n", file=headerFile) 
    
    def printValue(v):
       return 'v = %s;' % v     
    
    #print("// Do not directly edit this file. this file is auto generated by a custom build step\n", file=file)
    print(enumName + " "+ funcname + "(const std::string& s)\n{", file=file)   
    print("    const char *k = NULL;", file=file)
    print("    " + enumName + " v = (" + enumName + ")0;", file=file)
    print("    int sz = (int)s.size();", file=file)
    RecStrSw(printValue)._strBySize(file, names.items(), 4);
    print("\n    if (k == NULL || s != k)\n        return (" + enumName + ")0;\n    return v;", file=file)
    print("}", file=file)

    file.close()
    

if __name__ == "__main__":
    if len(sys.argv) == 1: # demo
        class StrO(dict):
            def __init__(self, s):
                self["stringv"] = s
                self["lengthv"] = len(s)
        strsss = {"AAAA":StrO("a"), "BBB":StrO("b"), "CCCCC":StrO("c"), "DDD":StrO("d"), "HELLO":StrO("e"), "AAAB":StrO("ee"),
                "HFLLO":StrO("f"), "AHELLO":StrO("g"), "DDDDWOW":StrO("h"), "DDDDBOW":StrO("i"), "DDDDKOW":StrO("j"), "DDDDBLW":StrO("k") }
        stringSwitch(sys.stdout, strsss, "demo")
    else:
        if sys.argv[1] == 'enum':
            if len(sys.argv) != 7:
                print("Usage: makeStringSwitch.py inFilename outName funcName enumName enumPrefix")
                sys.exit(1)
            stringEnumSwitch(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5], sys.argv[6])
        
        
        